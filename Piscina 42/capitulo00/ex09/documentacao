Agora vamos fazer o exercÃ­cio 09 como se estivÃ©ssemos em sala, absolutamente passo a passo, entendendo o que estÃ¡ acontecendo em nÃ­vel tÃ©cnico.

ğŸ“š ExercÃ­cio 09 â€” ft_magic
ğŸ¯ Objetivo

Criar um arquivo chamado:

ft_magic


Que permita que o comando:

file -m ft_magic arquivo


ReconheÃ§a um arquivo como:

42 file


Quando a string "42" estiver exatamente no 42Âº byte do arquivo.

ğŸ§  PARTE 1 â€” Entendendo o que Ã© um Magic File

O comando file identifica arquivos analisando seus bytes iniciais.

Exemplo:

file imagem.png


Ele lÃª o inÃ­cio do arquivo e reconhece a assinatura binÃ¡ria.

O parÃ¢metro:

file -m arquivo_magic arquivo


Permite que vocÃª forneÃ§a sua prÃ³pria regra de identificaÃ§Ã£o.

ğŸ§  PARTE 2 â€” Entendendo o byte 42

Importante:

No Unix, a contagem de bytes comeÃ§a em 0.

Byte lÃ³gico	Offset real
1Âº byte	0
2Âº byte	1
...	...
42Âº byte	41

âš ï¸ Portanto, precisamos usar offset 41.

ğŸ›  PARTE 3 â€” Criando o arquivo ft_magic
1ï¸âƒ£ Criar pasta do exercÃ­cio
mkdir ex09
cd ex09

2ï¸âƒ£ Criar o arquivo
touch ft_magic

3ï¸âƒ£ Editar o arquivo
nano ft_magic


Agora escreva exatamente:

41	string	42	42 file


âš ï¸ MUITO IMPORTANTE:

Os campos devem ser separados por TAB

NÃ£o use espaÃ§os

Deve haver apenas essa linha

No nano, pressione TAB normalmente entre os campos.

Salve e saia.

ğŸ§ª PARTE 4 â€” Criando um arquivo de teste corretamente

Agora precisamos criar um arquivo que tenha:

41 bytes qualquer

depois a string "42"

MÃ©todo seguro:
dd if=/dev/zero bs=1 count=41 of=teste 2>/dev/null
echo -n "42" >> teste

O que fizemos aqui?
Primeira linha:
dd if=/dev/zero bs=1 count=41 of=teste


if=/dev/zero â†’ gera bytes 0

bs=1 â†’ tamanho de bloco = 1 byte

count=41 â†’ cria 41 bytes

of=teste â†’ salva no arquivo teste

Agora o arquivo tem 41 bytes.

Segunda linha:
echo -n "42" >> teste


Adiciona "42" no final.

Agora:

Byte 41 â†’ comeÃ§a a string "42"

Exatamente como o exercÃ­cio exige.

ğŸ” PARTE 5 â€” Testando

Execute:

file -m ft_magic teste


Resultado esperado:

teste: 42 file


Se aparecer isso â†’ exercÃ­cio correto.

ğŸ§ª Teste negativo (para validar)

Crie outro arquivo:

echo "42" > errado


Teste:

file -m ft_magic errado


NÃ£o deve mostrar "42 file".

Isso prova que sua regra estÃ¡ correta.

ğŸ”¬ PARTE 6 â€” ExplicaÃ§Ã£o detalhada da linha do ft_magic

Linha:

41	string	42	42 file


Significa:

Parte	FunÃ§Ã£o
41	Offset (posiÃ§Ã£o do byte)
string	Tipo de dado a verificar
42	ConteÃºdo esperado
42 file	Mensagem que serÃ¡ exibida
ğŸ§  PARTE 7 â€” Como o file funciona internamente

O file:

LÃª byte por byte

Vai atÃ© offset 41

LÃª 2 bytes

Compara com "42"

Se bater â†’ imprime mensagem

Isso Ã© anÃ¡lise binÃ¡ria.

âš ï¸ Erros mais comuns na 42

âŒ Usar espaÃ§o ao invÃ©s de TAB
âŒ Usar offset 42 (errado)
âŒ Colocar quebra de linha extra
âŒ NÃ£o testar com -m
âŒ Usar echo errado e mudar os bytes

ğŸ“¦ Estrutura final para entrega
ex09/
â””â”€â”€ ft_magic


Nada mais.

ğŸ§  O que vocÃª aprendeu aqui

Offset binÃ¡rio

Como funciona o comando file

Estrutura de magic file

ManipulaÃ§Ã£o precisa de bytes

Testes binÃ¡rios controlados

Isso jÃ¡ Ã© nÃ­vel intermediÃ¡rio de Unix.